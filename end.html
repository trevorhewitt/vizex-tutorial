<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1"
  />
  <title>XX — Template</title>
  <link rel="stylesheet" href="assets/style.css"/>
  <style>
    .page { max-width: 900px; margin: 0 auto; padding: 24px; }
    .wait-wrap { margin-top:16px; }
    .footer { position: fixed; left: 0; right: 0; bottom: 0; padding: 12px 16px; }
    .button-bar { display: flex; gap: 12px; justify-content: space-between; }

    /* iPad friendliness */
    html, body {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      touch-action: manipulation; /* avoid dbl-tap zoom */
    }

    /* ===== Secret reset hotspot (invisible) =====
       Bottom-right 120x120 area above everything. */
    #resetHotspot {
      position: fixed;
      width: 120px;
      height: 120px;
      right: env(safe-area-inset-right, 0);
      bottom: calc(env(safe-area-inset-bottom, 0) + 4px);
      z-index: 99999;
      background: transparent;   /* completely invisible */
      /* no layout impact, no pointer cursor */
    }
  </style>
</head>
<body data-page="xx-template">
  <!-- Invisible admin-only hotspot -->
  <div id="resetHotspot" aria-hidden="true"></div>

  <div class="page">
    <div class="content">
      <div class="inner">
        <h1>You have now completed the practice trials. </h1>
        <p>Well done</p>

        <div class="wait-wrap" style="margin-top:16px;">
          <h1>WAIT</h1>
        </div>
        <p>Please wait a moment for the rest of the participants to finish as well.</p>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="button-bar">
      <button id="backBtn" class="secondary">Back</button>
      <button id="nextBtn" class="primary">Next</button>
    </div>
  </div>

  <script>
    // ============================
    // NAV (unchanged appearance)
    // ============================
    const NEXT_PAGE = "XX_set_next.html";
    const BACK_PAGE = "XX_set_back.html";

    function parseQuery() {
      const q = new URLSearchParams(location.search);
      return Object.fromEntries(q.entries());
    }
    function baseQueryString() {
      const { p, n, m } = parseQuery();
      const q = new URLSearchParams();
      if (p) q.set("p", p);
      if (n) q.set("n", n);
      q.set("m", (m === "1" ? "1" : "0"));
      return "?" + q.toString();
    }

    (function initNav() {
      const back = document.getElementById("backBtn");
      const next = document.getElementById("nextBtn");
      if (back) back.style.visibility = "hidden";
      if (next) next.style.visibility = "hidden";

      next?.addEventListener("click", () => {
        if (!NEXT_PAGE) return;
        location.href = NEXT_PAGE + baseQueryString();
      });

      back?.addEventListener("click", () => {
        if (!BACK_PAGE) return;
        location.href = BACK_PAGE + baseQueryString();
      });
    })();

    // ============================
    // iOS zoom suppression
    // ============================
    document.addEventListener("gesturestart", e => e.preventDefault(), { passive: false });
    (function preventIOSDoubleTapZoom() {
      let lastTouchEnd = 0;
      document.addEventListener("touchend", function (e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 350) e.preventDefault();
        lastTouchEnd = now;
      }, { passive: false });
    })();

    // ============================
    // Secret reset: two-finger long-press
    // Hotspot: bottom-right 120x120 area
    // Hold 2 fingers steady for HOLD_MS
    // Fallback: 7 taps in 4s
    // ============================
    (function initSecretReset() {
      const hotspot = document.getElementById('resetHotspot');
      if (!hotspot) return;

      const HOLD_MS = 1500;             // long-press duration
      const MAX_MOVE = 18;              // px per finger
      const REQUIRED_TOUCHES = 2;       // two-finger hold
      const TAP_FALLBACK_COUNT = 7;     // rapid taps fallback
      const TAP_FALLBACK_WINDOW = 4000; // ms

      let holdTimer = null;
      let startPositions = new Map();   // touchId -> {x,y}
      let activeIds = new Set();
      let tapCount = 0;
      let tapWindowTimer = null;

      function resetHold() {
        if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
        startPositions.clear();
        activeIds.clear();
      }

      function resetTaps() {
        tapCount = 0;
        if (tapWindowTimer) { clearTimeout(tapWindowTimer); tapWindowTimer = null; }
      }

      function successReset() {
        resetHold();
        resetTaps();
        // Navigate to /vizex-tutorial/ base without query params
        const path = location.pathname;
        const m = path.match(/^(.*\/vizex-tutorial\/)/);
        const base = location.origin + (m ? m[1] : path.replace(/[^/]*$/, ''));
        location.replace(base);
      }

      function touchesDistanceOK(ev) {
        for (const t of Array.from(ev.touches)) {
          if (!activeIds.has(t.identifier)) continue; // ignore if not one of our tracked
          const start = startPositions.get(t.identifier);
          if (!start) continue;
          const dx = t.clientX - start.x;
          const dy = t.clientY - start.y;
          if ((dx*dx + dy*dy) > (MAX_MOVE*MAX_MOVE)) return false;
        }
        return true;
      }

      function onTouchStart(ev) {
        // Only consider touches that start on the hotspot
        // Prevent default here to avoid any iOS zoom/callout
        ev.preventDefault();

        // If starting a new gesture, clear old state
        if (ev.touches.length >= REQUIRED_TOUCHES && activeIds.size === 0) {
          // Track the first REQUIRED_TOUCHES touches that are on the hotspot
          for (let i = 0; i < ev.touches.length && activeIds.size < REQUIRED_TOUCHES; i++) {
            const t = ev.touches[i];
            activeIds.add(t.identifier);
            startPositions.set(t.identifier, { x: t.clientX, y: t.clientY });
          }

          if (activeIds.size === REQUIRED_TOUCHES) {
            if (holdTimer) clearTimeout(holdTimer);
            holdTimer = setTimeout(successReset, HOLD_MS);
          }
        }

        // Fallback: 7 rapid taps
        if (ev.touches.length === 1) {
          tapCount += 1;
          if (!tapWindowTimer) {
            tapWindowTimer = setTimeout(resetTaps, TAP_FALLBACK_WINDOW);
          }
          if (tapCount >= TAP_FALLBACK_COUNT) {
            successReset();
          }
        }
      }

      function onTouchMove(ev) {
        // If we are in a hold, verify both tracked touches haven’t moved too far
        if (activeIds.size === REQUIRED_TOUCHES && holdTimer) {
          if (!touchesDistanceOK(ev)) {
            resetHold();
          }
        }
      }

      function onTouchEnd(ev) {
        // If any tracked finger lifts before timer fires → cancel
        for (const changed of Array.from(ev.changedTouches)) {
          if (activeIds.has(changed.identifier)) {
            resetHold();
            break;
          }
        }
        // Note: taps fallback handled by start/end counts + timer window
      }

      // Attach listeners specifically to the hotspot
      hotspot.addEventListener('touchstart', onTouchStart, { passive: false });
      hotspot.addEventListener('touchmove',  onTouchMove,  { passive: false });
      hotspot.addEventListener('touchend',   onTouchEnd,   { passive: false });
      hotspot.addEventListener('touchcancel', onTouchEnd,  { passive: false });

      // Also support PointerEvents (desktop testing), but tablet uses touch*
      if (window.PointerEvent) {
        hotspot.addEventListener('pointerdown', (e) => {
          // Simulate tap fallback with pointer on desktop
          tapCount += 1;
          if (!tapWindowTimer) {
            tapWindowTimer = setTimeout(resetTaps, TAP_FALLBACK_WINDOW);
          }
          if (tapCount >= TAP_FALLBACK_COUNT) successReset();
        }, { passive: true });
      }
    })();
  </script>
</body>
</html>
