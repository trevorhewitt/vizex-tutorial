<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1"
  />
  <title>XX — Template</title>
  <link rel="stylesheet" href="assets/style.css"/>
  <style>
    .page { max-width: 900px; margin: 0 auto; padding: 24px; }
    .wait-wrap { margin-top:16px; }
    .footer { position: fixed; left: 0; right: 0; bottom: 0; padding: 12px 16px; }
    .button-bar { display: flex; gap: 12px; justify-content: space-between; }

    html, body {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      touch-action: manipulation; /* allow taps, avoid dbl-tap zoom */
    }
  </style>
</head>
<body data-page="xx-template">
  <div class="page">
    <div class="content">
      <div class="inner">
        <h1>You have now completed the practice trials. </h1>
        <p>Well done</p>

        <div class="wait-wrap" style="margin-top:16px;">
          <h1>WAIT</h1>
        </div>
        <p>Please wait a moment for the rest of the participants to finish as well.</p>
      </div>
    </div>
  </div>

  <div class="footer">
    <div class="button-bar">
      <button id="backBtn" class="secondary">Back</button>
      <button id="nextBtn" class="primary">Next</button>
    </div>
  </div>

  <script>
    // ============================
    // NAV (unchanged appearance)
    // ============================
    const NEXT_PAGE = "XX_set_next.html";
    const BACK_PAGE = "XX_set_back.html";

    function parseQuery() {
      const q = new URLSearchParams(location.search);
      return Object.fromEntries(q.entries());
    }
    function baseQueryString() {
      const { p, n, m } = parseQuery();
      const q = new URLSearchParams();
      if (p) q.set("p", p);
      if (n) q.set("n", n);
      q.set("m", (m === "1" ? "1" : "0"));
      return "?" + q.toString();
    }

    (function initNav() {
      const back = document.getElementById("backBtn");
      const next = document.getElementById("nextBtn");
      if (back) back.style.visibility = "hidden";
      if (next) next.style.visibility = "hidden";

      next?.addEventListener("click", () => {
        if (!NEXT_PAGE) return;
        location.href = NEXT_PAGE + baseQueryString();
      });

      back?.addEventListener("click", () => {
        if (!BACK_PAGE) return;
        location.href = BACK_PAGE + baseQueryString();
      });
    })();

    // ============================
    // iOS zoom suppression
    // ============================
    document.addEventListener("gesturestart", e => e.preventDefault(), { passive: false });
    (function preventIOSDoubleTapZoom() {
      let lastTouchEnd = 0;
      document.addEventListener("touchend", function (e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 350) e.preventDefault();
        lastTouchEnd = now;
      }, { passive: false });
    })();

    // ============================
    // Secret gesture (tablet-first)
    // Tap Above → Below → Above → Below relative to the WAIT block
    // ============================
    (function initSecretGesture() {
      const REQUIRED = ["above", "below", "above", "below"];
      const WINDOW_MS = 8000;
      let progress = 0;
      let timer = null;

      const waitWrap = document.querySelector(".wait-wrap");
      const footer = document.querySelector(".footer");

      if (!waitWrap) return;

      function resetSeq() {
        progress = 0;
        if (timer) { clearTimeout(timer); timer = null; }
      }
      function armWindow() {
        if (timer) clearTimeout(timer);
        timer = setTimeout(resetSeq, WINDOW_MS);
      }

      function classifyTap(clientY) {
        const rect = waitWrap.getBoundingClientRect();
        if (clientY < rect.top) return "above";
        if (clientY > rect.bottom) return "below";
        return "inside";
      }

      function onPoint(ev) {
        // Ignore taps that originate on the footer (to avoid accidental triggers)
        const target = ev.target;
        if (footer && (target === footer || target.closest(".footer"))) return;

        // Prefer touch points for accuracy on iPad
        let clientY;
        if (ev instanceof TouchEvent) {
          if (ev.touches.length > 1) return; // ignore multi-touch
          clientY = ev.touches[0]?.clientY ?? ev.changedTouches[0]?.clientY;
        } else {
          clientY = ev.clientY;
        }
        if (clientY == null) return;

        const where = classifyTap(clientY);
        if (where === "inside") {
          // Tapping directly on the WAIT block doesn't count; reset grace.
          resetSeq();
          return;
        }

        if (REQUIRED[progress] === where) {
          if (progress === 0) armWindow();
          progress += 1;

          if (progress >= REQUIRED.length) {
            // Success → go to /vizex-tutorial/ root with NO query params.
            const path = location.pathname;
            const m = path.match(/^(.*\/vizex-tutorial\/)/);
            const base = location.origin + (m ? m[1] : path.replace(/[^/]*$/, ''));
            location.replace(base);
            return;
          }
        } else {
          // Wrong side; restart, but allow immediate restart if first matches
          resetSeq();
          if (REQUIRED[0] === where) {
            progress = 1;
            armWindow();
          }
        }
      }

      // Use pointer events where available; fall back to touch/click.
      if (window.PointerEvent) {
        // On iPadOS Safari 17+, pointerdown works reliably.
        window.addEventListener("pointerdown", onPoint, { passive: true });
      } else {
        window.addEventListener("touchstart", onPoint, { passive: true });
        window.addEventListener("mousedown", onPoint, { passive: true });
      }

      // Recompute sequence if layout changes significantly (orientation change)
      window.addEventListener("orientationchange", resetSeq, { passive: true });
      window.addEventListener("resize", resetSeq, { passive: true });
    })();
  </script>
</body>
</html>
